# Rafael Luque's PhD Thesis notes

Notes and resources about my PhD only interesting for my future me.

Anyway, if you want to have a look then browse to [Rafael Luque's PhD Thesis](https://luque.github.io/phd-notes/)


# Overview

Industry statistics as a whole have failed to improve much since 1.968, when software
engineering and scientific management were introduced as means for resolving the
*software crisis*. Unfortunately abandoned projects, cost/time overruns, and bloated,
buggy software still dominate the landscape.

In spite of the efforts to mitigate this situation –- like XP, agile, software craftsmanship or
DDD--- the reality is that a usual software project stack involves an increasingly larger
number of programming languages, DSLs, frameworks, systems, tools, techniques and
processes, so it is a fact that the accidental complexity in our day-to-day software
projects is increasing to unbearable levels.

As we have conceived the software development we see as natural that once a
programmer has adquired enough knowledge about a problem domain and has conceived
a mental model for this domain we must wait for days or weeks before seeing a running
prototype and maybe months before a production-quality piece of software be ready.
We argue that this is an unacceptable consequence of our failed conception about the
software development activity, but not an inherent characteristic to the nature of software
development.

Nowadays the programming we have invented requires developers to jump continuously
between very different thinking levels –--like the conceptual, the source code or the
runtime levels--- trying to tracing back and forth between a domain concept and the code
that represents it, or between a defect and the affected source code or application
behaviour.

We claim that programming should be reconsidered as a mainly learning, exploring and
modeling activity and programmers should be able to capture their applications in an
executable domain model from which to obtain running prototypes efforlessly and immediately.
In the other hand, we have constrained the developers range of experiences in a tiny
subset of their intellectual capabilities: sitting at a desk, staring at a computer screen and
typing in a keyboard.

We think this is the wrong way to understand or think about a complex system. The right
way is to model it and explore it. So we need a new kind of media to create *dynamic
models* in real time in the middle of a modeling conversation with other developers or
domain experts.

We plan to build a new breed of **dynamic and fully conceptual modeling environment** in
order to enable programmers to work through every development stage –-analysis,
specification, design, implementation, deployment, evolution, etc.--- at the conceptual
level and explore their dynamic models as a thinking and learning tool.
